## 컴퓨터 구조
: 컴퓨터는 H/W와 S/W가 합쳐진 형태
- H/W는 전자회로 및 기계 장치로 되어 입출력 장치, 중앙처리장치(CPU), 기억장치 등으로 구성되어 있으며, S/W의 경우 하드웨어를 제어하며 작업을 수행하는 프로그램임
### 입력 장치 (I)
: 컴퓨터가 이해할 수 있는 형식으로 데이터와 명령을 받아드리는 물리 장치
- 컴퓨터와 외부에서 연결하여 사용할 수 있는 형태

### 출력 장치 (O)
: 사람이 이해할 수 있는 형식으로 데이터를 출력하는 물리 장치
- ex) 모니터, 프린터

### 중앙처리 장치 (CPU)
:CPU의 내부 구성은 크게 산술/논리 연산 장치(ALU)와 제어 장치, 레지스터로 구성되어 있음
- ALU 산술 덧셈 수행
- 제어장치 프로그램에 따라 명령과 제어 신호 생성후 장치 제어
- 레이스터 CPU 내부 메모리로 CPU의 데이터를 일시적으로 저장하고 날림

### 저장 장치
: 저장장치는 데이터나 프로그램을 보관하기 위한 일차 기억 장치인 주 기억 장치(Memory)와 주 기억 장치를 보조하기 위한 디스크와 씨디 같은 보조 기억 장치로 이루어짐
- 주기억 장치 RAM & ROM
- 보조기억 장치 디스크, 광 디스크, 플래쉬 메모리

### CPU & Memory
#### CPU의 구조 
![](https://velog.velcdn.com/images/ghwo9611/post/78c20715-3d56-44ab-bf26-f0cad5da357d/image.png)

- 산술/논리 연산 장치
: 캐시 및 메모리로부터 데이터를 읽어 오고 레지스터에 저장함, 해당 데이터를 가져와 연산함, 가산기, 보수기, 누산기, 기억레지스터, 데이터 레지스터 등으로 구성됨

- 레지스터
: CPU안에 있는 내부 기억장치로, 연산 장치에 주로 사용되는 범용 레지스터와 특수목적에 사용되는 전용 레지스터가 있음
	- IR (Instruction Register): 현재 수행중인 명령어 부호 저장
    - PC (Program Counter): 명령이 저장된 메모리 주소 저장
    - AC (Accumulator): 연산 결과를 기억함(누산)
    
- 제어장치
: CPU가 자신 주변기기들을 컨트롤하는 장치로, 구현 방식에는 Hardwired와 Micro Program이 있음
	- 프로그램 계수기 : 프로그램 순서 제어
	- 명령 레지스터 : 명령어 내용 임시 기억
	- 명령 해독기 : 레지스터에 수록된 명령을 해독하여 수행될 장치에 제어신호 전송

#### CPU의 기능
: 명령어와 명령어 수행과정 및 처리에 깊은 연관

- 명령어
 - 동작코드: 명령어 실행 동작 구분 표현
 - 오퍼랜드: 명령어의 실행에 필요한 자료나 실제 자료의 저장 위치 표현
 
- 명령어 수행과정
 FI(읽기) - DI(해석) - EI(실행) - WB(기록)
 
- 명령어 처리 방식
	- CISC
    : 사용하는 명령어 세트를 단순화 시켜 처리하는 방식
    	- 여러사이클이 존재하고, 복잡한 마이크로 프로그램 구조가지고, 파이프라이닝 어려움
        
    - RISC
    : 명령어의 개수를 줄여 명령어 해석시간을 줄이는 방식
    	- 하나의 사이클이 존재하며, 복잡한 컴파일러 구조가지고, 파이프라이닝 가능

#### Memory
##### 메모리 분류 별 특성
![](https://velog.velcdn.com/images/ghwo9611/post/48ec8c40-8090-4123-ab11-c8bba4ef5f20/image.png)

##### 메모리 성능
- 리프레쉬 시간
: 최근 접근 이후 다시 접근까지 걸리는 시간
- 메모리 엑세스 시간
: 명령이 이후 데이터 최초의 접근까지의 시간
- 사이클 시간 (리프레쉬 시간 + 메모리 엑세스 시간)
: 메모리 접근에 걸리는 시간의 주기
##### 메모리 종류
- 주기억 장치
>RAM : 휘발성 데이터 저장 장치
>ROM : 비휘발성 데이터 저장 장치
- 보조기억 장치
> 자기 디스크
> 광 디스크
> 플래시 메모리

- 캐시 메모리
: 레지스터와 메인 메모리 사이에서 완충하는 역할을 하며, 캐시 메모리에 자주 사용하는 데이터를 저장하고 CPU에서 요구할 경우 메인메모리까지 접근하는 것이 아닌 캐쉬 메모리에서 가져가 사용할 수 있도록함
- cache hit
: 캐시에 데이터가 있어 접근가능할 경우
- cache miss
: 캐시에 데이터가 없어 접근 못한 경우

## 운영체제
### OS
: 운영체제는 응용 프로그램이 하드웨어에게 일을 시킬 수 있도록 도와주며 하드웨어를 구성하는 일을 하는 CPU, 자료를 저장하는 RAM, 디스크 등의 시스템 자원을 관리하는 주체

### 프로세스
#### 프로세스 구성 요소
- 유저 메모리 영역 관리: 각각의 프로세스가 가지게 되는 독립된 메모리 공간
- 핸들 테이블: 프로세스에서 사용하는 모든 핸들에 대한 커널 객체 포인터 정보를 배열 형태로 가지고 있는 공간

### 프로세스 특징
- 자원 소유의 단위: 각 프로세스는 자신의 실행 이미지 로드와 실행에 필요한 독립되고 추가적인 메모리 공간
- 디스패칭의 단위: 하나의 프로그램이 CPU 자원을 일정 기간 할당 받은 단위를 뜻하며, 여러개의 프로세스와 하나의 프로세스에서 여러개의 디스패칭이 발생할 수 있음

### 프로세스 상태
- 실행 : 프로그램 동작중
- 준비 : 실행 준비 완료후 할당 되기 까지 기다림
- 대기 : I/O 및 다른 이벤트 발생 대기

++ 프로세스(process)와 프로세서(processor 구분해야 함)

### 스레드
![](https://velog.velcdn.com/images/ghwo9611/post/ad8b8f8c-a79c-4055-8149-7ae0d31a2e5c/image.png)
명령어가 CPU를 통해 수행되는 객체 단위
 - 각 스레드는 같은 코드, 데이터, 힙에 접근할 수 있지만 각 스레드 내부에 위치한 스택 메모리는 공유할 수 없음
 - 하나의 프로세는 하나의 명령 및 동작을 수행함
 - 각각의 스레드는 독립적으로 동작하기에 멀티스레드의 경우 각 프로세스의 종료 시점이 비동기적임( 멀티 스레드를 사용한 처리 효율 & 동기적 처리 따로 요구)
 #### 싱글 스레드 vs 멀티 스레드
 싱글 스레드
 - 동기화 처리를 신경 x, 동시적인 자원 접근에 대한 에러 x, cpu 부화 적음
 - 자체적으로 프로세스간 자원 공유 x, 순차적인 작원 처리로 인한 비효율, 에러 발생시 스레드 멈춤
 
 멀티 스레드
 - 각 작업에 따른 실시간 응답, 동시적인 작업 처리로 인한 처리 효율성
 - 동시적인 자원 접근에 대한 에러 우려, cpu 부하 증가 우려, 스레드 제어는 해당 프로세서만 가능
 
 #### 동시성 vs 병렬성
 - 동시성(시분할): 여러개의 스레드를 할당 시간만큼 동작하고 다음 스레드를 처리하는 방법으로 동시에 처리하는 것처럼 느껴지도록 처리하는 방식
 - 병렬성: 멀티 코어 환경에서 여러개의 스레드를 작용해 여러 동작을 동시에 처리함

### 문자열과 그래픽
#### 문자열
- ASCII
: 알파벳을 인코딩으로 7bit에 표현할 수 있는 대표적인 문자 인코딩 방식

- 유니코드
: 현존하는 문자 인코딩 방법을 모두 유니코드로 교체하는 것을 목표하며 문자 인코딩, 문장 정보 데이터베이스등을 포함하는 산업 표준으로 아스키 코드를 확장한 형태

- UTF-?
: UTF 유니코드로 인코딩하는 방식을 의미하며 -뒤에 오는 숫자는 한 문자를 표현하기 위해 기본적으로 사용하는 bit수를 나타냄 (utf-8, utf-16)
#### 그래픽

- 비트맵
: 디지털 이미지를 저장하는데 가장 많이 사용되는 이미지 파일 포맷 형식으로, 이미지를 격자형 픽셀 단위로 구성해 저장함. 특유의 계단 현상이 있지만, 컴퓨터에 부하가 적다는 장점 (jpg, png, gif..)
- 벡터
: 이미지를 수하적인 공식으로 표현하는 방식으로 점과 점, 선과 선을 연결해 이미지를 표현함. 계단현상이 발생하지 않고, 기본적으로 컴퓨터에 상대적으로 부하가 있을 수 있지만 이미지를 확대하고 줄여도 수학적으로 표현한다는 특징 덕분에 용량에 변환 없음 (svg, ai)

### 가비지 컬랙션
: 객체가 생성 되었을 때 메모리를 할당하고 해당 메모리가 유효하지 않게 되었을 때(가비지), 해당 메모리를 자동으로 해제 해주는 기능
#### 대표적 가비지 컬렉션 방법

- 레퍼런스 카운팅
: 한 객체를 참조하는 변수의 수를 추적하는 방법으로 가장 단순한 형태의 가비지 컬렉션 알고리즘
- 변수의 레퍼런스가 복사될 때마다 카운트가 증가하고 카운트가 0( 아무도 참조 x )이 될 시 메모리를 해제할 수 있는 상태가 되는 방식으로, 해당 방식은 순환 참조로 인한 문제가 발생할 수 있음

- 트레이싱
: 한 객체에 flag를 두고, 가비지 컬렉션 사이클마다 flag에 표시 후 삭제하는 mark and sweep 방법

아래의 과정을 통해 reachable한지 판단함
> root와 root의 자식들을 검사해 활성 여부를 판단해 가비지인지 판단하고 root에서 접근할 수 없으면 가비지로 분류함
> 이후 활성상태가 아닌(가비지) 메모리를 모두 OS에 반환

- 메모리 누수
: 예상치 못한 참조로 인해 발생한 누수

- 우발적으로 생성된 전역변수
- DOM 외부에서의 참조
- 클로저의 잘못된 사용


- 출처 코드스테이츠